#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <mpxtn.h>

#ifdef _WIN32
#include <intrin.h>
#endif

static inline uint64_t get_cycles() {
#ifdef _WIN32
	return __rdtsc();
#else
	uint64_t t;
	__asm volatile ("rdtsc" : "=A"(t));
	return t;
#endif
}

const static size_t _storm_size = 683;
const static uint8_t _storm_data[] = {
0x50, 0x54, 0x43, 0x4f, 0x4c, 0x4c, 0x41, 0x47, 0x45, 0x2d, 0x30, 0x37, 0x31, 0x31, 0x31, 0x39,
0x9d, 0x03, 0x00, 0x00, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x56, 0x35, 0x0f, 0x00, 0x00, 0x00,
0xe0, 0x01, 0x04, 0x00, 0x00, 0xf0, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45,
0x76, 0x65, 0x6e, 0x74, 0x20, 0x56, 0x35, 0xa2, 0x01, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00,
0x01, 0x0c, 0x00, 0x00, 0x02, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x06, 0xa4, 0x03,
0x00, 0x02, 0x06, 0xa4, 0x03, 0x00, 0x00, 0x06, 0xe0, 0x03, 0x00, 0x01, 0x02, 0x80, 0x96, 0x01,
0x00, 0x02, 0x02, 0x80, 0x96, 0x01, 0x00, 0x00, 0x02, 0x80, 0xce, 0x01, 0x00, 0x01, 0x01, 0x80,
0x3c, 0x00, 0x02, 0x01, 0x80, 0x3c, 0x00, 0x00, 0x01, 0x80, 0x3c, 0x00, 0x01, 0x04, 0x68, 0x00,
0x02, 0x04, 0x68, 0x00, 0x00, 0x04, 0x68, 0x00, 0x00, 0x05, 0x1c, 0x00, 0x02, 0x0e, 0xcd, 0x99,
0xb3, 0xfa, 0x03, 0x00, 0x02, 0x0f, 0x28, 0x00, 0x01, 0x0f, 0x58, 0x00, 0x00, 0x0f, 0x48, 0x3c,
0x01, 0x02, 0x80, 0x9a, 0x01, 0x00, 0x02, 0x02, 0x80, 0x9a, 0x01, 0x78, 0x02, 0x05, 0x58, 0xf0,
0x01, 0x02, 0x05, 0x50, 0x3c, 0x01, 0x02, 0x80, 0x90, 0x01, 0x00, 0x02, 0x02, 0x80, 0x90, 0x01,
0x78, 0x00, 0x02, 0x80, 0xbe, 0x01, 0xe8, 0x02, 0x02, 0x05, 0x40, 0x78, 0x01, 0x02, 0x80, 0x94,
0x01, 0x00, 0x02, 0x02, 0x80, 0x94, 0x01, 0xac, 0x02, 0x02, 0x05, 0x30, 0xf0, 0x01, 0x00, 0x02,
0x80, 0xc2, 0x01, 0xf0, 0x01, 0x01, 0x02, 0x80, 0x96, 0x01, 0x00, 0x02, 0x02, 0x80, 0x96, 0x01,
0x3c, 0x01, 0x02, 0x80, 0x9c, 0x01, 0x00, 0x02, 0x02, 0x80, 0x9c, 0x01, 0x3c, 0x02, 0x05, 0x20,
0xac, 0x02, 0x01, 0x05, 0x60, 0xe8, 0x02, 0x01, 0x02, 0x80, 0xa8, 0x01, 0x00, 0x02, 0x02, 0x80,
0xa8, 0x01, 0x3c, 0x01, 0x05, 0x58, 0x78, 0x00, 0x02, 0x80, 0xd0, 0x01, 0x00, 0x02, 0x05, 0x30,
0xa4, 0x03, 0x02, 0x05, 0x50, 0x3c, 0x00, 0x02, 0x80, 0xbc, 0x01, 0x78, 0x01, 0x02, 0x80, 0x9e,
0x01, 0x00, 0x02, 0x02, 0x80, 0x9e, 0x01, 0xac, 0x02, 0x02, 0x05, 0x58, 0x00, 0x01, 0x05, 0x50,
0xf0, 0x01, 0x02, 0x05, 0x60, 0xf0, 0x01, 0x01, 0x05, 0x48, 0xac, 0x02, 0x00, 0x02, 0x80, 0xca,
0x01, 0x3c, 0x01, 0x02, 0x80, 0x96, 0x01, 0x00, 0x02, 0x02, 0x80, 0x96, 0x01, 0x3c, 0x01, 0x02,
0x80, 0x96, 0x01, 0x00, 0x02, 0x02, 0x80, 0x96, 0x01, 0x00, 0x01, 0x05, 0x40, 0xa4, 0x03, 0x01,
0x05, 0x38, 0xf0, 0x01, 0x01, 0x05, 0x30, 0x78, 0x00, 0x02, 0x80, 0xd2, 0x01, 0xa4, 0x03, 0x01,
0x02, 0x80, 0x92, 0x01, 0x00, 0x02, 0x02, 0x80, 0x92, 0x01, 0x3c, 0x00, 0x02, 0x80, 0xde, 0x01,
0xd8, 0x04, 0x01, 0x05, 0x38, 0xf0, 0x01, 0x00, 0x02, 0x80, 0xce, 0x01, 0xf0, 0x01, 0x01, 0x05,
0x40, 0x3c, 0x01, 0x02, 0x80, 0x96, 0x01, 0x00, 0x02, 0x02, 0x80, 0x96, 0x01, 0xf0, 0x01, 0x01,
0x05, 0x48, 0x78, 0x01, 0x05, 0x50, 0x3c, 0x01, 0x05, 0x58, 0x78, 0x01, 0x05, 0x60, 0x6d, 0x61,
0x74, 0x65, 0x50, 0x54, 0x4e, 0x20, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x03, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x50, 0x54, 0x4e, 0x4f, 0x49, 0x53,
0x45, 0x2d, 0x62, 0x03, 0x33, 0x01, 0x86, 0xdf, 0x01, 0x02, 0x14, 0x03, 0x00, 0x64, 0xe8, 0x07,
0x64, 0x00, 0x00, 0x04, 0x00, 0xc0, 0xb8, 0x02, 0x9c, 0x04, 0x00, 0x34, 0x03, 0x00, 0x64, 0xe8,
0x07, 0x64, 0x00, 0x00, 0x04, 0x00, 0x90, 0x4e, 0x50, 0x00, 0x04, 0x00, 0x1e, 0x64, 0x00, 0x61,
0x73, 0x73, 0x69, 0x57, 0x4f, 0x49, 0x43, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73,
0x74, 0x72, 0x65, 0x61, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e,
0x75, 0x6d, 0x20, 0x55, 0x4e, 0x49, 0x54, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x61,
0x73, 0x73, 0x69, 0x55, 0x4e, 0x49, 0x54, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75,
0x2d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x00, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0x61,
0x73, 0x73, 0x69, 0x55, 0x4e, 0x49, 0x54, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x75,
0x2d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x00, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0x61,
0x73, 0x73, 0x69, 0x55, 0x4e, 0x49, 0x54, 0x14, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x75,
0x2d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x00, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0x70,
0x78, 0x74, 0x6f, 0x6e, 0x65, 0x4e, 0x44, 0x00, 0x00, 0x00, 0x00,
};

void usage(const char *cmd) {
	printf("usage: %s <ptcop file> [<wavfile>]\n", cmd);
}

int main(int argc, char *argv[]) {

	int ret = 1;
	FILE *fp = NULL;
	FILE *wfp = NULL;
	MPXTN *mp = NULL;
	char buf[4096];
	size_t readed = 0;
	size_t r = 0;

	if(argc != 1 && argc != 2 && argc != 3) {
		usage(argv[0]);
		return 1;
	}

	if(argc >= 2) {
		fp = fopen(argv[1], "rb");

		if(!fp) {
			fprintf(stderr, "fopen(%s) for read failed.\n", argv[1]);
			goto End;
		}
	}

	if(argc == 3) {
		wfp = fopen(argv[2], "wb");
		if(!wfp) {
			fprintf(stderr, "fopen(%s) for write failed.\n", argv[2]);
			goto End;
		}
	}

	if(argc == 1) {
		mp = mpxtn_mread(_storm_data, _storm_size, NULL);
	} else {
		mp = mpxtn_fread(fp, NULL);
	}
	if(!mp) {
		fprintf(stderr, "mpxtn_read failed!\n");
		goto End;
	}

	printf("ptcop file loaded.\n");

	/* show info */
	printf("expected %zu samples\n", mpxtn_get_total_samples(mp));
	printf("repeat %zu sample\n", mpxtn_get_repeat_sample(mp));

	uint64_t start = get_cycles();
	uint64_t end = get_cycles();
	uint64_t diff = 0;
	uint64_t cycle_sum = 0;
	uint64_t cycle_min = UINT64_MAX;
	uint64_t cycle_max = 0;
	uint64_t cycle_cnt = 0;
	bool end_vomit = false;

	if(wfp) {
		size_t smp_num = mpxtn_get_total_samples(mp);
		struct {
			char     r_tag[4];
			uint32_t r_len;
			char     w_tag[4];
			char     f_tag[4];
			uint32_t f_len;
			uint16_t format;
			uint16_t channel;
			uint32_t sps;
			uint32_t byte_rate;
			uint16_t block_align;
			uint16_t bps;
			char     d_tag[4];
			uint32_t d_len;
		} header = {
			.f_len       = 16,
			.format      = 1,
			.channel     = 2,
			.sps         = 44100,
			.byte_rate   = 176400,
			.block_align = 4,
			.bps         = 16
		};

		memcpy(header.r_tag, "RIFF", 4);
		memcpy(header.w_tag, "WAVE", 4);
		memcpy(header.f_tag, "fmt ", 4);
		memcpy(header.d_tag, "data", 4);

		header.d_len = (uint32_t)smp_num * 4;
		header.r_len = header.d_len + 32;

		/* write header */
		fwrite(&header, sizeof(header), 1, wfp);
	}

	while(!end_vomit) {
		start = get_cycles();
		r = mpxtn_vomit(buf, 1024, mp);
		end = get_cycles();
		readed += r;

		if(end > start) {
			diff = end - start;
			cycle_sum += diff;
			if(diff < cycle_min) cycle_min = diff;
			if(diff > cycle_max) cycle_max = diff;
			cycle_cnt++;
		}

		if(r > 0 && wfp) {
			fwrite(buf, r * 4, 1, wfp);
		}

		if(r != 1024) end_vomit = true;
	}

	printf("vomit %zu samples\n", readed);

	if(cycle_cnt > 0) {
		uint64_t cycle_avg = cycle_sum / cycle_cnt;
		printf("elapsed: avg: %zu cycles\n", cycle_avg);
		printf("elapsed: min: %zu cycles\n", cycle_min);
		printf("elapsed: max: %zu cycles\n", cycle_max);
	}

	ret = 0;
End:
	if(fp) fclose(fp);
	if(wfp) fclose(wfp);
	if(mp) mpxtn_close(mp);

	if(ret) {
		printf("read file error.\n");
	}

	return ret;
}


